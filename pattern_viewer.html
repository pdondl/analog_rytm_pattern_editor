<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analog Rytm Pattern Viewer</title>
  <style>
    :root {
      --bg:         #111;
      --surface:    #1c1c1c;
      --border:     #2a2a2a;
      --fg:         #ddd;
      --muted:      #555;
      --accent:     #e05a00;
      --trig-on:    #e05a00;
      --trig-off:   #202020;
      --step-size:  32px;
      --step-gap:   2px;
      --group-gap:  8px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--fg);
      font-family: 'Courier New', monospace;
      font-size: 13px;
      padding: 28px;
      min-height: 100vh;
    }

    h1 {
      color: var(--accent);
      font-size: 1.1em;
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.8em;
      letter-spacing: 1px;
      margin-bottom: 24px;
    }

    /* Controls */
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    button {
      background: var(--surface);
      border: 1px solid #3a3a3a;
      color: var(--fg);
      padding: 7px 16px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85em;
      letter-spacing: 1px;
      border-radius: 2px;
    }
    button:hover:not(:disabled) {
      border-color: var(--accent);
      color: var(--accent);
    }
    button:disabled { opacity: 0.35; cursor: default; }

    #status {
      font-size: 0.8em;
      padding: 6px 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 2px;
      color: var(--muted);
    }
    #status.ok  { color: #5cb85c; border-color: #2d4a2d; }
    #status.err { color: #d9534f; border-color: #4a2d2d; }

    #port-info {
      font-size: 0.75em;
      color: var(--muted);
      margin-bottom: 20px;
      min-height: 1em;
    }

    /* Pattern meta info */
    #pattern-meta {
      font-size: 0.8em;
      color: var(--muted);
      margin-bottom: 14px;
      letter-spacing: 1px;
      min-height: 1em;
    }
    #pattern-meta span { color: var(--fg); }

    /* Grid */
    #grid-wrap { overflow-x: auto; padding-bottom: 8px; }

    .grid {
      display: inline-block;
      white-space: nowrap;
    }

    /* Step-number ruler */
    .ruler-row {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .track-label-space {
      flex: 0 0 66px;
    }
    .ruler-groups {
      display: flex;
      gap: var(--group-gap);
    }
    .ruler-group {
      display: flex;
      gap: var(--step-gap);
    }
    .ruler-num {
      width: var(--step-size);
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      line-height: 1;
    }

    /* Track rows */
    .track-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .track-label {
      flex: 0 0 66px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      padding-right: 10px;
      gap: 2px;
      font-size: 0.75em;
      color: var(--muted);
      letter-spacing: 1px;
    }
    .track-meta {
      font-size: 0.82em;
      color: #444;
      letter-spacing: 0;
    }
    .track-steps {
      display: flex;
      gap: var(--group-gap);
    }
    .step-group {
      display: flex;
      gap: var(--step-gap);
    }

    .step {
      width: var(--step-size);
      height: var(--step-size);
      border-radius: 1px;
      background: var(--trig-off);
      border: 1px solid #2a2a2a;
      cursor: pointer;
      flex-shrink: 0;
      position: relative;
    }
    .step.on {
      background: var(--trig-on);
      border-color: #ff7722;
      box-shadow: 0 0 5px rgba(224, 90, 0, 0.4);
    }
    /* Accented trig: bright amber */
    .step.on.accent {
      background: #ffbb44;
      border-color: #ffdd77;
      box-shadow: 0 0 6px rgba(255, 187, 68, 0.5);
    }
    /* Muted trig: grey — programmed but won't fire */
    .step.on.mute {
      background: #404040;
      border-color: #606060;
      box-shadow: none;
    }
    /* Steps beyond track length are dimmed */
    .step.inactive {
      opacity: 0.2;
    }
    /* Trig modifier dots */
    .trig-dot {
      position: absolute;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      pointer-events: none;
    }
    /* Retrig — top-right; dark ring keeps it visible on bright accent steps */
    .trig-dot.retrig { top:  2px; right: 2px; background: #ddcc22;
                       box-shadow: 0 0 0 1px rgba(0,0,0,0.45); }
    /* Swing — stacked just below retrig in top-right */
    .trig-dot.swing  { top: 12px; right: 2px; background: #4499ff;
                       box-shadow: 0 0 0 1px rgba(0,0,0,0.35); }

    /* UTIME arrow — bottom-centre of step, points right (late) or left (early) */
    .utime-arrow {
      position: absolute;
      bottom: 3px;
      left: 50%;
      transform: translateX(-50%);
      width: 0; height: 0;
      pointer-events: none;
    }
    .utime-arrow.late  { border-top: 4px solid transparent;
                         border-bottom: 4px solid transparent;
                         border-left:  6px solid rgba(255,220,100,0.85); }
    .utime-arrow.early { border-top: 4px solid transparent;
                         border-bottom: 4px solid transparent;
                         border-right: 6px solid rgba(255,220,100,0.85); }

    /* Lock trig: parameter lock present, but no sound trigger */
    .step.lock-trig {
      background: #0e1f2a;
      border-color: #2a6080;
      box-shadow: 0 0 3px rgba(42, 96, 128, 0.35);
    }
    /* Upper-left corner indicators — sound-lock (cyan) takes the triangle;
       plock (purple) takes the triangle when no sound-lock, or a stripe when both. */
    .step.has-sound-lock::before,
    .step.has-plock:not(.has-sound-lock)::before {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 0; height: 0;
      border-style: solid;
      border-width: 10px 10px 0 0;
      border-color: #44ccdd transparent transparent transparent; /* cyan default */
    }
    .step.has-plock:not(.has-sound-lock)::before {
      border-color: #cc44aa transparent transparent transparent; /* purple when no snd-lock */
    }
    /* Both active: plock stripe extends from the sound-lock triangle */
    .step.has-plock.has-sound-lock::after {
      content: '';
      position: absolute;
      top: 0; left: 10px;
      width: 5px; height: 3px;
      background: #cc44aa;
    }
    /* Inspected step: ring around the cell */
    .step.inspected {
      box-shadow: 0 0 0 2px #cc44aa !important;
      z-index: 1;
    }
    /* Outer wrapper for steps — provides positioning context for slide lines */
    .steps-outer {
      position: relative;
    }
    /* Slide connector line drawn below the step boxes */
    .slide-line {
      position: absolute;
      top: 34px;
      height: 2px;
      background: #44cc77;
      border-radius: 1px;
      pointer-events: none;
    }

    /* Page toggle */
    .page-ctrl {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }
    .page-btn.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Group separator lines */
    .group-sep {
      width: 1px;
      height: var(--step-size);
      background: #2a2a2a;
      flex-shrink: 0;
      align-self: center;
    }

    .note {
      margin-top: 22px;
      font-size: 0.72em;
      color: var(--muted);
      line-height: 1.6;
    }
    .note a { color: #666; }

    /* ── Step inspector panel ──────────────────────────────────────────────── */

    .step-panel {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: #131a20;
      border: 1px solid #2a4a6a;
      border-radius: 2px;
      padding: 8px 10px;
      margin-bottom: 6px;
      white-space: normal;
    }

    .sp-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.72em;
      color: var(--muted);
      letter-spacing: 1px;
      padding-bottom: 4px;
      border-bottom: 1px solid #1e2e3a;
    }
    .sp-close {
      background: none;
      border: none;
      color: #446;
      font-size: 1.1em;
      padding: 0 2px;
      cursor: pointer;
      line-height: 1;
      letter-spacing: 0;
    }
    .sp-close:hover { color: var(--fg); border: none; }

    .sp-sections {
      display: flex;
      gap: 6px;
      overflow-x: auto;
      padding-bottom: 2px;
    }

    /* Individual section box */
    .sp-sec {
      flex-shrink: 0;
      background: #161e26;
      border: 1px solid #1e2e3a;
      border-radius: 2px;
      padding: 5px 7px;
    }
    .sp-sec-head {
      font-size: 0.62em;
      color: #446688;
      letter-spacing: 2px;
      text-align: center;
      margin-bottom: 5px;
      text-transform: uppercase;
    }

    /* Flags column */
    .sp-flags {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .sp-flag {
      font-size: 0.68em;
      padding: 2px 6px;
      border: 1px solid #1e2e3a;
      border-radius: 1px;
      color: #334;
      text-align: center;
      letter-spacing: 1px;
      min-width: 34px;
    }
    .sp-flag.on {
      color: var(--accent);
      border-color: #703000;
      background: #1a0e00;
    }

    /* Parameter rows */
    .sp-params {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .sp-param {
      display: flex;
      align-items: baseline;
      gap: 5px;
    }
    .sp-lbl {
      font-size: 0.65em;
      color: #446;
      text-align: right;
      letter-spacing: 0.5px;
      min-width: 28px;
    }
    .sp-val {
      font-size: 0.78em;
      color: var(--fg);
      min-width: 26px;
    }
    .sp-val.locked {
      color: #cc44aa;
    }

    /* SYN/SMP/ENV/LFO flag row inside TRIG section */
    .sp-sw-row {
      display: flex;
      gap: 3px;
      margin-top: 3px;
    }
    .sp-sw-row .sp-flag {
      min-width: 26px;
      font-size: 0.63em;
    }
  </style>
</head>
<body>

  <h1>Analog Rytm Pattern Viewer</h1>
  <div class="subtitle">USB MIDI &mdash; Workbuffer &mdash; Step trigs</div>

  <div class="controls">
    <button id="btn-connect">Connect MIDI</button>
    <button id="btn-refresh" disabled>Request Pattern</button>
    <div id="status">Not connected</div>
  </div>

  <div id="port-info"></div>
  <div id="pattern-meta"></div>

  <div class="page-ctrl">
    <button id="btn-page0" class="page-btn active">1 &ndash; 32</button>
    <button id="btn-page1" class="page-btn">33 &ndash; 64</button>
  </div>

  <div id="grid-wrap">
    <div class="grid" id="grid"></div>
  </div>

  <div class="note">
    Connects to the first MIDI port whose name contains &ldquo;rytm&rdquo; (case-insensitive).<br>
    Requests the current workbuffer pattern and kit via SysEx. Dimmed cells = beyond track step count.<br>
    Trig colours:
      <span style="color:#e05a00">&#9632;</span>&thinsp;normal &ensp;
      <span style="color:#ffbb44">&#9632;</span>&thinsp;accent &ensp;
      <span style="color:#606060">&#9632;</span>&thinsp;mute &ensp;
      <span style="color:#2a6080">&#9632;</span>&thinsp;lock trig (plock, no sound) &mdash;
    <span style="color:#44ccdd">&#9699;</span>&thinsp;sound lock (top-left triangle) &ensp;
      <span style="color:#cc44aa">&#9699;</span>&thinsp;plock — triangle when no sound lock, purple stripe alongside when both &mdash;
    Dots: <span style="color:#ddcc22">&#9679;</span>&thinsp;retrig (top-right) &ensp;
      <span style="color:#4499ff">&#9679;</span>&thinsp;swing below retrig (hidden when pattern swing = 50%) &mdash;
    <span style="color:rgba(255,220,100,0.85)">&#9654;</span>/<span style="color:rgba(255,220,100,0.85)">&#9664;</span>&thinsp;micro-timing arrow (bottom-centre, right=late/left=early).<br>
    Slide: <span style="color:#44cc77">&#9644;</span>&thinsp;green line below row, from slide step to next trig&thinsp;/&thinsp;lock (same page only).<br>
    <kbd style="color:#888">&#8984;+click</kbd> any step to inspect parameter locks. FW 1.70 binary format (compatible with 1.72).
  </div>

  <script>
    // ─── Constants from libanalogrytm/sysex.h and pattern.h ──────────────────

    const AR_PRODUCT_ID              = 0x07;
    const AR_ELEKTRON_MFR_1          = 0x20;
    const AR_ELEKTRON_MFR_2          = 0x3C;
    const AR_SYSEX_DUMP_ID_PATTERN   = 0x54;   // saved pattern dump
    const AR_SYSEX_DUMPX_ID_PATTERN  = 0x5A;   // workbuffer pattern dump
    const AR_SYSEX_DUMPX_ID_KIT      = 0x58;   // workbuffer kit dump
    const AR_TRIG_ENABLE             = 0x0001;  // bit 0
    const AR_TRIG_RETRIG             = 0x0002;  // bit 1
    const AR_TRIG_MUTE               = 0x0004;  // bit 2
    const AR_TRIG_ACCENT             = 0x0008;  // bit 3
    const AR_TRIG_SWING              = 0x0010;  // bit 4
    const AR_TRIG_SLIDE              = 0x0020;  // bit 5: slide
    const AR_TRIG_LFO_PL_EN          = 0x0040;  // bit  6: enable LFO p-lock
    const AR_TRIG_SYN_PL_SW          = 0x0080;  // bit  7: SYN voices retrigger
    const AR_TRIG_SMP_PL_SW          = 0x0100;  // bit  8: SMP voice retrigger
    const AR_TRIG_ENV_PL_SW          = 0x0200;  // bit  9: ENV retrigger
    const AR_TRIG_LFO_PL_SW          = 0x0400;  // bit 10: LFO retrigger
    const AR_TRIG_SYN_PL_EN          = 0x0800;  // bit 11: enable SYN p-lock
    const AR_TRIG_SMP_PL_EN          = 0x1000;  // bit 12: enable SMP p-lock
    const AR_TRIG_ENV_PL_EN          = 0x2000;  // bit 13: enable ENV p-lock

    const AR_NUM_TRACKS              = 13;
    const AR_NUM_STEPS               = 64;
    const TRACK_V5_SZ                = 0x0281;  // 641 bytes / track (FW1.70)
    const TRIG_BITS_OFFSET           = 0;       // trig_bits[112] at track offset 0

    // Track field offsets from track start in raw decoded pattern.
    // Formula: @comment_in_pattern_h - 4 (the 4 magic bytes at pattern start).
    const SOUND_LOCK_OFFSET          = 0x0237;  // sound_locks[64] @0x023B  0xFF=no lock, 0x00-0x7F=pool slot 1-128 (0-indexed)
    const NOTE_OFFSET                = 0x0070;  // notes[64]       @0x0074
    const VELOCITY_OFFSET            = 0x00B0;  // velocities[64]  @0x00B4
    const NOTE_LEN_OFFSET            = 0x00F0;  // note_lengths[64]@0x00F4
    const MICRO_TIMING_OFFSET        = 0x0130;  // micro_timings[64]  @0x0134
    const RETRIG_LENGTH_OFFSET       = 0x0170;  // retrig_lengths[64] @0x0174
    const RETRIG_RATE_OFFSET         = 0x01B0;  // retrig_rates[64]   @0x01B4
    const RETRIG_VELO_OFFSET         = 0x01F0;  // retrig_velocity_offsets[64] @0x01F4
    const DEFAULT_NOTE_OFFSET        = 0x0230;  // default_note    @0x0234
    const DEFAULT_VELOCITY_OFFSET    = 0x0231;  // default_velocity@0x0235
    const DEFAULT_NOTE_LEN_OFFSET    = 0x0232;  // default_note_len@0x0236
    const DEFAULT_TRIG_FLAGS_OFFSET  = 0x0233;  // default_trig_flags (s_u16_t, hi byte first) @0x0237
    const NUM_STEPS_OFFSET           = 0x0235;  // num_steps       @0x0239
    const TRACK_SPEED_OFFSET         = 0x0277;  // flags_and_speed @0x027B
    const TRIG_PROBABILITY_OFFSET    = 0x0278;  // trig_probability@0x027C

    // P-Lock sequences
    const PLOCK_SEQS_BASE            = 0x2091;
    const PLOCK_SEQ_SZ               = 0x42;    // 66 bytes
    const NUM_PLOCK_SEQS             = 72;

    // Pattern-level metadata
    const MASTER_LENGTH_OFFSET       = 0x3321;
    const KIT_NUMBER_OFFSET          = 0x3325;
    const SWING_AMOUNT_OFFSET        = 0x3326;
    const BPM_MSB_OFFSET             = 0x332A;
    const BPM_LSB_OFFSET             = 0x332B;

    // Kit raw layout
    const KIT_TRACKS_BASE            = 0x002E;  // ar_sound_t tracks[12] @kit+0x002E
    const AR_SOUND_V5_SZ             = 162;     // sizeof(ar_sound_t)

    // Track speed labels
    const TRACK_SPEED_LABELS = ['2x', '3/2x', '1x', '3/4x', '1/2x', '1/4x', '1/8x'];

    // Workbuffer pattern request (0x6A)
    const PATTERN_REQUEST_X = new Uint8Array([
      0xF0, 0x00, 0x20, 0x3C, 0x07,
      0x00, 0x6A, 0x01, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x05, 0xF7
    ]);

    // Workbuffer kit request (0x68)
    const KIT_REQUEST_X = new Uint8Array([
      0xF0, 0x00, 0x20, 0x3C, 0x07,
      0x00, 0x68, 0x01, 0x01, 0x00,
      0x00, 0x00, 0x00, 0x05, 0xF7
    ]);

    const TRACK_NAMES = ['BD','SD','RS','CP','BT','LT','MT','HT','CH','OH','CY','CB','FX'];

    // ─── Plock parameter info ─────────────────────────────────────────────────
    // Maps plock_type → { section, label, soundOff }
    // soundOff is the byte offset within ar_sound_t (s_u16_t fields: read the
    // first/hi byte which carries the 0-127 value; lo byte is always 0).

    const PLOCK_INFO = {
      0x00: { sec:'SRC',  lbl:'P1',   sndOff:0x1C },
      0x01: { sec:'SRC',  lbl:'P2',   sndOff:0x1E },
      0x02: { sec:'SRC',  lbl:'P3',   sndOff:0x20 },
      0x03: { sec:'SRC',  lbl:'P4',   sndOff:0x22 },
      0x04: { sec:'SRC',  lbl:'P5',   sndOff:0x24 },
      0x05: { sec:'SRC',  lbl:'P6',   sndOff:0x26 },
      0x06: { sec:'SRC',  lbl:'P7',   sndOff:0x28 },
      0x07: { sec:'SRC',  lbl:'P8',   sndOff:0x2A },
      0x08: { sec:'SMPL', lbl:'TUN',  sndOff:0x2C },
      0x09: { sec:'SMPL', lbl:'FIN',  sndOff:0x2E },
      0x0A: { sec:'SMPL', lbl:'NR',   sndOff:0x30 },
      0x0B: { sec:'SMPL', lbl:'BR',   sndOff:0x32 },
      0x0C: { sec:'SMPL', lbl:'STA',  sndOff:0x34 },
      0x0D: { sec:'SMPL', lbl:'END',  sndOff:0x36 },
      0x0E: { sec:'SMPL', lbl:'LOOP', sndOff:0x38 },
      0x0F: { sec:'SMPL', lbl:'LEV',  sndOff:0x3A },
      0x10: { sec:'FLTR', lbl:'ATK',  sndOff:0x3C },
      0x11: { sec:'FLTR', lbl:'SUS',  sndOff:0x3E },
      0x12: { sec:'FLTR', lbl:'DEC',  sndOff:0x40 },
      0x13: { sec:'FLTR', lbl:'REL',  sndOff:0x42 },
      0x14: { sec:'FLTR', lbl:'FRQ',  sndOff:0x44 },
      0x15: { sec:'FLTR', lbl:'RES',  sndOff:0x46 },
      0x16: { sec:'FLTR', lbl:'TYP',  sndOff:0x48 },
      0x17: { sec:'FLTR', lbl:'ENV',  sndOff:0x4A },
      0x18: { sec:'AMP',  lbl:'ATK',  sndOff:0x4C },
      0x19: { sec:'AMP',  lbl:'HLD',  sndOff:0x4E },
      0x1A: { sec:'AMP',  lbl:'DEC',  sndOff:0x50 },
      0x1B: { sec:'AMP',  lbl:'DRV',  sndOff:0x52 },
      0x1C: { sec:'AMP',  lbl:'DLY',  sndOff:0x54 },
      0x1D: { sec:'AMP',  lbl:'REV',  sndOff:0x56 },
      0x1E: { sec:'AMP',  lbl:'PAN',  sndOff:0x58 },
      0x1F: { sec:'AMP',  lbl:'VOL',  sndOff:0x5A },
      // 0x20: unknown — skipped
      0x21: { sec:'LFO',  lbl:'SPD',  sndOff:0x5E },
      0x22: { sec:'LFO',  lbl:'MLT',  sndOff:0x60 },
      0x23: { sec:'LFO',  lbl:'FAD',  sndOff:0x62 },
      0x24: { sec:'LFO',  lbl:'DST',  sndOff:0x64 },
      0x25: { sec:'LFO',  lbl:'WAV',  sndOff:0x66 },
      0x26: { sec:'LFO',  lbl:'PHS',  sndOff:0x68 },
      0x27: { sec:'LFO',  lbl:'MOD',  sndOff:0x6A },
      0x28: { sec:'LFO',  lbl:'DEP',  sndOff:0x6C },
    };

    const SECTION_KEYS = ['SRC','SMPL','FLTR','AMP','LFO'];

    // Retrig rate labels: index 0-16, matching AR display (0=1/1, 16=1/80)
    const RETRIG_RATE_LABELS = [
      '1/1','1/2','1/3','1/4','1/5','1/6','1/8','1/10',
      '1/12','1/16','1/20','1/24','1/32','1/40','1/48','1/64','1/80',
    ];

    // Trig condition names (indexed by AR_TRIG_CONDITION_* enum, 0-56)
    const TRIG_COND_NAMES = [
      '1%','3%','4%','6%','9%','13%','19%','25%','33%','41%',
      '50%','59%','67%','75%','81%','87%','91%','94%','96%','98%',
      '99%','100%','FILL','!FILL','PRE','!PRE','NEI','!NEI',
      '1ST','!1ST','1:2','2:2','1:3','2:3','3:3','1:4','2:4','3:4','4:4',
      '1:5','2:5','3:5','4:5','5:5','1:6','2:6','3:6','4:6','5:6','6:6',
      '1:7','2:7','3:7','4:7','5:7','6:7','7:7',
    ];

    // ─── State ────────────────────────────────────────────────────────────────

    let midiAccess  = null;
    let rytmInput   = null;
    let rytmOutput  = null;
    let sysexBuf    = [];
    let inSysex     = false;
    let lastRaw     = null;    // decoded pattern bytes
    let lastKit     = null;    // decoded kit bytes
    let plockValues = null;    // plockValues[track] = Map<plockType, Uint8Array[64]>
    let stepPage    = 0;
    let openPanel   = null;    // { t, s, el }

    // ─── UI refs ──────────────────────────────────────────────────────────────

    const btnConnect  = document.getElementById('btn-connect');
    const btnRefresh  = document.getElementById('btn-refresh');
    const btnPage0    = document.getElementById('btn-page0');
    const btnPage1    = document.getElementById('btn-page1');
    const statusEl    = document.getElementById('status');
    const portInfoEl  = document.getElementById('port-info');
    const metaEl      = document.getElementById('pattern-meta');
    const gridEl      = document.getElementById('grid');

    // ─── UI helpers ───────────────────────────────────────────────────────────

    function setStatus(msg, cls) {
      statusEl.textContent = msg;
      statusEl.className   = cls || '';
    }

    // ─── MIDI connect ─────────────────────────────────────────────────────────

    async function connectMidi() {
      setStatus('Connecting to MIDI…');
      try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: true });
      } catch (e) {
        setStatus('MIDI access denied: ' + e.message, 'err');
        return;
      }
      midiAccess.onstatechange = () => {
        const hadRytm = !!(rytmInput && rytmOutput);
        findPorts();
        if (!hadRytm && rytmInput && rytmOutput) requestPattern();
      };
      findPorts();
      if (rytmInput && rytmOutput) requestPattern();
    }

    btnConnect.addEventListener('click', connectMidi);
    btnRefresh.addEventListener('click', requestPattern);

    function findPorts() {
      rytmInput  = null;
      rytmOutput = null;

      const inNames  = [];
      const outNames = [];

      for (const [, p] of midiAccess.inputs) {
        inNames.push(p.name);
        if (p.name.toLowerCase().includes('rytm')) rytmInput = p;
      }
      for (const [, p] of midiAccess.outputs) {
        outNames.push(p.name);
        if (p.name.toLowerCase().includes('rytm')) rytmOutput = p;
      }

      portInfoEl.textContent =
        'IN: ' + (inNames.join(', ') || '—') +
        '   OUT: ' + (outNames.join(', ') || '—');

      if (rytmInput && rytmOutput) {
        rytmInput.onmidimessage = onMidiMessage;
        setStatus('Connected → ' + rytmInput.name, 'ok');
        btnRefresh.disabled = false;
      } else {
        setStatus('Analog Rytm not found — connect the device and try again.', 'err');
        btnRefresh.disabled = true;
      }
    }

    btnPage0.addEventListener('click', () => {
      stepPage = 0;
      btnPage0.classList.add('active');
      btnPage1.classList.remove('active');
      if (lastRaw) renderGrid(lastRaw, stepPage);
    });

    btnPage1.addEventListener('click', () => {
      stepPage = 1;
      btnPage1.classList.add('active');
      btnPage0.classList.remove('active');
      if (lastRaw) renderGrid(lastRaw, stepPage);
    });

    connectMidi();

    function requestPattern() {
      if (!rytmOutput) return;
      sysexBuf = [];
      inSysex  = false;
      setStatus('Requesting pattern…');
      rytmOutput.send(PATTERN_REQUEST_X);
      rytmOutput.send(KIT_REQUEST_X);
    }

    // ─── Receive & reassemble SysEx ───────────────────────────────────────────

    function onMidiMessage(ev) {
      const data = ev.data;
      for (let i = 0; i < data.length; i++) {
        const b = data[i];
        if (b === 0xF0) {
          inSysex  = true;
          sysexBuf = [0xF0];
        } else if (inSysex) {
          sysexBuf.push(b);
          if (b === 0xF7) {
            inSysex = false;
            handleSysex(new Uint8Array(sysexBuf));
            sysexBuf = [];
          }
        }
      }
    }

    // ─── SysEx handler ────────────────────────────────────────────────────────

    function handleSysex(syx) {
      if (syx.length < 20) return;
      if (syx[0] !== 0xF0)              return;
      if (syx[1] !== 0x00)              return;
      if (syx[2] !== AR_ELEKTRON_MFR_1) return;
      if (syx[3] !== AR_ELEKTRON_MFR_2) return;
      if (syx[4] !== AR_PRODUCT_ID)     return;

      const dumpId = syx[6];

      // ── Kit dump ──────────────────────────────────────────────────────────
      if (dumpId === AR_SYSEX_DUMPX_ID_KIT) {
        let raw;
        try { raw = decodeSysex7to8(syx); } catch (e) { return; }
        lastKit = raw;
        // Re-render open panel if any to update kit defaults
        if (openPanel) {
          const { t, s } = openPanel;
          openPanel.el.replaceWith(buildStepPanel(t, s));
          openPanel.el = gridEl.querySelector('.step-panel');
        }
        return;
      }

      // ── Pattern dump ─────────────────────────────────────────────────────
      const isPattern =
        dumpId === AR_SYSEX_DUMP_ID_PATTERN ||
        dumpId === AR_SYSEX_DUMPX_ID_PATTERN;
      if (!isPattern) return;

      const objNr  = syx[9];
      const isWB   = (dumpId === AR_SYSEX_DUMPX_ID_PATTERN);
      const patName = isWB ? 'Workbuffer' : patternSlotName(objNr);

      setStatus('Decoding ' + syx.length + ' bytes…');

      let raw;
      try {
        raw = decodeSysex7to8(syx);
      } catch (e) {
        setStatus('Decode error: ' + e.message, 'err');
        return;
      }

      const kitNum    = raw.length > KIT_NUMBER_OFFSET    ? raw[KIT_NUMBER_OFFSET]   : 0xFF;
      const kitStr    = (kitNum === 0xFF) ? '—' : String(kitNum + 1).padStart(2, '0');
      const bpmRaw    = raw.length > BPM_LSB_OFFSET
        ? (raw[BPM_MSB_OFFSET] << 8) | raw[BPM_LSB_OFFSET] : 0;
      const bpmStr    = bpmRaw ? (bpmRaw / 120).toFixed(1) : '—';
      const swingAmt  = raw.length > SWING_AMOUNT_OFFSET  ? raw[SWING_AMOUNT_OFFSET] : 0;
      const masterLen = raw.length > MASTER_LENGTH_OFFSET + 1
        ? raw[MASTER_LENGTH_OFFSET] | (raw[MASTER_LENGTH_OFFSET + 1] << 8) : 0;
      const masterStr = (masterLen === 0 || masterLen > 128) ? 'INF' : masterLen;

      metaEl.innerHTML =
        'Pattern: <span>' + patName + '</span> &ensp;' +
        'Kit: <span>'     + kitStr  + '</span> &ensp;' +
        'BPM: <span>'     + bpmStr  + '</span> &ensp;' +
        'Swing: <span>'   + (50 + swingAmt) + '%</span> &ensp;' +
        'Master: <span>'  + masterStr + '</span>';

      lastRaw = raw;
      parsePlocks(raw);
      renderGrid(raw, stepPage);
      setStatus('Ready', 'ok');
    }

    function patternSlotName(n) {
      const bank = String.fromCharCode(65 + Math.floor(n / 16));
      const slot = String(1 + (n % 16)).padStart(2, '0');
      return bank + slot;
    }

    // ─── 7-bit SysEx → 8-bit raw decode ──────────────────────────────────────

    function decodeSysex7to8(syx) {
      const dataStart = 10;
      const dataEnd   = syx.length - 5;
      const syxDatSz  = dataEnd - dataStart;
      if (syxDatSz <= 0) throw new Error('Empty payload');

      const raw  = [];
      let pkbNr  = 0;
      let msbs   = 0;

      for (let i = 0; i < syxDatSz; i++) {
        const b = syx[dataStart + i];
        if (pkbNr === 0) {
          msbs = b;
        } else {
          raw.push(b | (msbs & 0x80));
        }
        msbs  = (msbs << 1) & 0xFF;
        pkbNr = (pkbNr + 1) & 7;
      }

      return new Uint8Array(raw);
    }

    // ─── Trig flags from packed 14-bit bitstream ──────────────────────────────

    function getTrigFlags(trigBits, stepIdx) {
      const startBit = 14 * stepIdx;
      const numBits  = 14;
      let r        = 0;
      let byteOff  = startBit >> 3;
      let bitOff   = startBit - (byteOff << 3);
      let outShift = numBits;
      let bitsLeft = numBits;

      while (bitsLeft > 0) {
        const bitsAvail = 8 - bitOff;
        if (bitsLeft < bitsAvail) {
          outShift -= bitsLeft;
          r |= ((trigBits[byteOff] >> (bitsAvail - bitsLeft)) & ((1 << bitsLeft) - 1)) << outShift;
          bitsLeft = 0;
        } else {
          outShift -= bitsAvail;
          r |= (trigBits[byteOff] & ((1 << bitsAvail) - 1)) << outShift;
          bitsLeft -= bitsAvail;
          bitOff    = 0;
          byteOff++;
        }
      }
      return r;
    }

    // ─── Plock parsing ────────────────────────────────────────────────────────
    // Scans plock_seqs and populates module-level `plockValues`.
    // Returns a plockMap[track][step] presence array for use in renderGrid.

    function parsePlocks(raw) {
      const values = Array.from({length: AR_NUM_TRACKS}, () => new Map());
      const map    = Array.from({length: AR_NUM_TRACKS}, () => new Uint8Array(AR_NUM_STEPS));

      const end = PLOCK_SEQS_BASE + NUM_PLOCK_SEQS * PLOCK_SEQ_SZ;
      if (raw.length >= end) {
        for (let si = 0; si < NUM_PLOCK_SEQS; si++) {
          const base   = PLOCK_SEQS_BASE + si * PLOCK_SEQ_SZ;
          const plType = raw[base];
          const trkNr  = raw[base + 1];
          if (plType === 0xFF || trkNr === 0xFF || trkNr >= AR_NUM_TRACKS) continue;

          let arr = values[trkNr].get(plType);
          if (!arr) { arr = new Uint8Array(AR_NUM_STEPS).fill(0xFF); values[trkNr].set(plType, arr); }

          for (let s = 0; s < AR_NUM_STEPS; s++) {
            const v = raw[base + 2 + s];
            if (v !== 0xFF) { arr[s] = v; map[trkNr][s] = 1; }
          }
        }
      }

      plockValues = values;
      return map;
    }

    // ─── Render grid ──────────────────────────────────────────────────────────

    function renderGrid(raw, page) {
      closeStepPanel();
      gridEl.innerHTML = '';

      const GROUPS    = 2;
      const GROUP_SZ  = 16;
      const STEP_W    = 32;
      const STEP_GAP  = 2;
      const GROUP_GAP = 8;
      const stepOffset = page * 32;

      const swingAmount = (raw.length > SWING_AMOUNT_OFFSET) ? raw[SWING_AMOUNT_OFFSET] : 0;

      const plockMap = parsePlocks(raw);

      function stepCenterX(pageIdx) {
        const g = Math.floor(pageIdx / GROUP_SZ);
        const s = pageIdx % GROUP_SZ;
        const gw = GROUP_SZ * STEP_W + (GROUP_SZ - 1) * STEP_GAP;
        return g * (gw + GROUP_GAP) + s * (STEP_W + STEP_GAP) + STEP_W / 2;
      }

      // ── Ruler ─────────────────────────────────────────────────────────────
      const ruler = document.createElement('div');
      ruler.className = 'ruler-row';
      const rulerSpace = document.createElement('div');
      rulerSpace.className = 'track-label-space';
      ruler.appendChild(rulerSpace);
      const rulerGroups = document.createElement('div');
      rulerGroups.className = 'ruler-groups';
      for (let g = 0; g < GROUPS; g++) {
        const grp = document.createElement('div');
        grp.className = 'ruler-group';
        for (let s = 0; s < GROUP_SZ; s++) {
          const n = document.createElement('div');
          n.className = 'ruler-num';
          const stepNum = stepOffset + g * GROUP_SZ + s + 1;
          if (stepNum % 4 === 1) n.textContent = stepNum;
          grp.appendChild(n);
        }
        rulerGroups.appendChild(grp);
      }
      ruler.appendChild(rulerGroups);
      gridEl.appendChild(ruler);

      // ── Track rows ────────────────────────────────────────────────────────
      for (let t = 0; t < AR_NUM_TRACKS; t++) {
        const trackBase = 4 + t * TRACK_V5_SZ;
        const trigBits  = raw.subarray(trackBase + TRIG_BITS_OFFSET, trackBase + 112);
        const numSteps  = raw[trackBase + NUM_STEPS_OFFSET];
        const speedByte = raw[trackBase + TRACK_SPEED_OFFSET];
        const speedStr  = TRACK_SPEED_LABELS[speedByte & 0x07] || '1x';

        const row = document.createElement('div');
        row.className = 'track-row';
        row.dataset.track = t;

        // ── Label ──
        const label = document.createElement('div');
        label.className = 'track-label';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = TRACK_NAMES[t];
        const metaSpan = document.createElement('span');
        metaSpan.className = 'track-meta';
        metaSpan.textContent = speedStr + '\u00B7' + numSteps;
        label.appendChild(nameSpan);
        label.appendChild(metaSpan);
        row.appendChild(label);

        // ── Steps outer ──
        const stepsOuter = document.createElement('div');
        stepsOuter.className = 'steps-outer';
        const stepsWrap = document.createElement('div');
        stepsWrap.className = 'track-steps';

        const slideSteps  = new Array(32).fill(false);
        const activeSteps = new Array(32).fill(false);

        for (let g = 0; g < GROUPS; g++) {
          const grp = document.createElement('div');
          grp.className = 'step-group';

          for (let s = 0; s < GROUP_SZ; s++) {
            const pageIdx  = g * GROUP_SZ + s;
            const stepIdx  = stepOffset + pageIdx;
            const flags    = getTrigFlags(trigBits, stepIdx);
            const isOn     = (flags & AR_TRIG_ENABLE) !== 0;
            const isAccent = (flags & AR_TRIG_ACCENT) !== 0;
            const isMute   = (flags & AR_TRIG_MUTE)   !== 0;
            const isRetrig = (flags & AR_TRIG_RETRIG) !== 0;
            const hasSwing = (flags & AR_TRIG_SWING)  !== 0;
            const isSlide  = (flags & AR_TRIG_SLIDE)  !== 0;
            const beyond   = stepIdx >= numSteps;
            // Per-step locks stored in track arrays (not plock_seqs)
            const noteRaw    = lastRaw[trackBase + NOTE_OFFSET     + stepIdx];
            const veloRaw    = lastRaw[trackBase + VELOCITY_OFFSET + stepIdx];
            const lenRaw     = lastRaw[trackBase + NOTE_LEN_OFFSET + stepIdx];
            // notes bit 7: 1=no condition, 0=has condition (independent of note lock)
            const hasTrigCond  = !beyond && (noteRaw & 0x80) === 0;
            const noteLocked   = !beyond && (noteRaw & 0x7F) !== 0x7F;
            const veloLocked   = !beyond && veloRaw !== 0xFF;
            const lenLocked    = !beyond && lenRaw  !== 0xFF;
            const microRaw     = lastRaw[trackBase + MICRO_TIMING_OFFSET + stepIdx];
            const microVal     = microRaw & 0x3F;
            const microSigned  = (microVal & 0x20) ? microVal - 64 : microVal;
            const hasPlock = !beyond && (
              plockMap[t][stepIdx] !== 0 ||
              noteLocked || veloLocked || lenLocked || hasTrigCond || microSigned !== 0
            );
            const sndLock  = lastRaw[trackBase + SOUND_LOCK_OFFSET + stepIdx];
            const hasSoundLock = !beyond && sndLock !== 0xFF;

            const enBits     = flags & 0x3840;
            const swBits     = flags & 0x0780;
            const isLockTrig = !beyond && (
              (!isOn && hasPlock) ||
              (isOn && swBits === 0 && enBits !== 0)
            );

            if (!beyond) {
              if (isOn || isLockTrig) activeSteps[pageIdx] = true;
              if (isOn && isSlide)    slideSteps[pageIdx]  = true;
            }

            const cell = document.createElement('div');
            let cls = 'step';

            if (isLockTrig) {
              cls += ' lock-trig';
            } else if (isOn) {
              cls += ' on';
              if (isAccent && !isMute) cls += ' accent';
              if (isMute)              cls += ' mute';
              if (hasPlock)            cls += ' has-plock';
            }
            if (hasSoundLock) cls += ' has-sound-lock';
            if (beyond) cls += ' inactive';
            cell.className = cls;
            cell.dataset.step = stepIdx;

            if (isOn) {
              if (isRetrig) { const d = document.createElement('div'); d.className = 'trig-dot retrig'; cell.appendChild(d); }
              if (hasSwing && swingAmount !== 0) { const d = document.createElement('div'); d.className = 'trig-dot swing'; cell.appendChild(d); }
            }
            if ((isOn || isLockTrig) && microSigned !== 0) {
              const arr = document.createElement('div');
              arr.className = 'utime-arrow ' + (microSigned > 0 ? 'late' : 'early');
              cell.appendChild(arr);
            }

            // Tooltip
            const modParts = [];
            if (hasPlock) modParts.push('PLOCK');
            if (isAccent) modParts.push('ACCENT');
            if (isMute)   modParts.push('MUTE');
            if (isRetrig) modParts.push('RETRIG');
            if (hasSwing && swingAmount !== 0) modParts.push('SWING');
            if (isSlide)      modParts.push('SLIDE');
            if (hasSoundLock) modParts.push('SND:' + (sndLock + 1));
            cell.title = TRACK_NAMES[t] + ' · step ' + (stepIdx + 1)
              + (isLockTrig ? ' · LOCK' : isOn ? ' · TRIG' : '')
              + (modParts.length ? ' [' + modParts.join(', ') + ']' : '')
              + (beyond ? ' · beyond' : '')
              + '\n⌘+click to inspect';

            // Cmd+click → open step inspector panel
            cell.addEventListener('click', (e) => {
              if (!e.metaKey && !e.ctrlKey) return;
              e.preventDefault();
              if (openPanel && openPanel.t === t && openPanel.s === stepIdx) {
                closeStepPanel();
              } else {
                openStepPanel(t, stepIdx);
              }
            });

            grp.appendChild(cell);
          }
          stepsWrap.appendChild(grp);
        }

        stepsOuter.appendChild(stepsWrap);

        // ── Slide lines ───────────────────────────────────────────────────
        for (let i = 0; i < 32; i++) {
          if (!slideSteps[i]) continue;
          for (let j = i + 1; j < 32; j++) {
            if (activeSteps[j]) {
              const x1 = stepCenterX(i);
              const x2 = stepCenterX(j);
              const line = document.createElement('div');
              line.className = 'slide-line';
              line.style.left  = x1 + 'px';
              line.style.width = (x2 - x1) + 'px';
              stepsOuter.appendChild(line);
              break;
            }
          }
        }

        row.appendChild(stepsOuter);
        gridEl.appendChild(row);
      }
    }

    // ─── Step inspector panel ─────────────────────────────────────────────────

    function openStepPanel(t, s) {
      closeStepPanel();

      const trackRow = gridEl.querySelector(`.track-row[data-track="${t}"]`);
      if (!trackRow) return;

      const panel = buildStepPanel(t, s);
      gridEl.insertBefore(panel, trackRow);
      openPanel = { t, s, el: panel };

      // Highlight the inspected step cell
      const stepEl = trackRow.querySelector(`.step[data-step="${s}"]`);
      if (stepEl) stepEl.classList.add('inspected');
    }

    function closeStepPanel() {
      if (!openPanel) return;
      // Remove highlight
      const trackRow = gridEl.querySelector(`.track-row[data-track="${openPanel.t}"]`);
      if (trackRow) {
        const stepEl = trackRow.querySelector(`.step[data-step="${openPanel.s}"]`);
        if (stepEl) stepEl.classList.remove('inspected');
      }
      openPanel.el.remove();
      openPanel = null;
    }

    function buildStepPanel(t, s) {
      const trackBase = 4 + t * TRACK_V5_SZ;
      const trigBits  = lastRaw.subarray(trackBase + TRIG_BITS_OFFSET, trackBase + 112);
      const flags     = getTrigFlags(trigBits, s);
      const isOn      = (flags & AR_TRIG_ENABLE) !== 0;
      const enBits    = flags & 0x3840;
      const swBits    = flags & 0x0780;
      const numSteps  = lastRaw[trackBase + NUM_STEPS_OFFSET];
      const beyond    = s >= numSteps;
      const hasPlock  = plockValues && plockValues[t].size > 0 &&
        [...plockValues[t].values()].some(arr => arr[s] !== 0xFF);
      const isLockTrig = !beyond && (
        (!isOn && hasPlock) || (isOn && swBits === 0 && enBits !== 0)
      );
      const trigType = beyond ? 'BEYOND' : isLockTrig ? 'LOCK TRIG' : isOn ? 'TRIG' : 'EMPTY';

      const panel = document.createElement('div');
      panel.className = 'step-panel';

      // Header
      const hdr = document.createElement('div');
      hdr.className = 'sp-header';
      const title = document.createElement('span');
      title.textContent = TRACK_NAMES[t] + ' · Step ' + (s + 1) + ' · ' + trigType;
      const closeBtn = document.createElement('button');
      closeBtn.className = 'sp-close';
      closeBtn.textContent = '×';
      closeBtn.addEventListener('click', closeStepPanel);
      hdr.appendChild(title);
      hdr.appendChild(closeBtn);
      panel.appendChild(hdr);

      // Sections row
      const secs = document.createElement('div');
      secs.className = 'sp-sections';

      secs.appendChild(buildFlagsSection(flags));
      secs.appendChild(buildTrigSection(t, s, flags));
      if (flags & AR_TRIG_RETRIG) secs.appendChild(buildRetrigSection(t, s, flags));
      for (const secKey of SECTION_KEYS) {
        secs.appendChild(buildParamSection(secKey, t, s));
      }

      panel.appendChild(secs);
      return panel;
    }

    // FLAGS section: ACC / MUT / SWG / SLD
    function buildFlagsSection(flags) {
      const flagDefs = [
        { lbl: 'ACC', on: (flags & AR_TRIG_ACCENT) !== 0 },
        { lbl: 'MUT', on: (flags & AR_TRIG_MUTE)   !== 0 },
        { lbl: 'SWG', on: (flags & AR_TRIG_SWING)  !== 0 },
        { lbl: 'SLD', on: (flags & AR_TRIG_SLIDE)  !== 0 },
      ];
      const body = document.createElement('div');
      body.className = 'sp-flags';
      for (const f of flagDefs) {
        const el = document.createElement('div');
        el.className = 'sp-flag' + (f.on ? ' on' : '');
        el.textContent = f.lbl;
        body.appendChild(el);
      }
      return makeSec('FLAGS', body);
    }

    // TRIG section: NOTE, VELO, LEN, PROB, then SYN/SMP/ENV/LFO
    // Returns the trig condition index (0–56, see TRIG_COND_NAMES) if a per-step
    // trig condition is set, or null if the step plays unconditionally.
    // Condition bits are packed across notes/micro_timings/retrig_lengths/retrig_rates
    // (see ar_pattern_track_get_step_trig_condition in pattern.c).
    // When notes[s] bit 7 = 1 → no condition; bit 7 = 0 → has condition.
    function getTrigCondition(trackBase, s) {
      const noteRaw = lastRaw[trackBase + NOTE_OFFSET + s];
      if ((noteRaw & 0x80) !== 0) return null; // bit 7 = 1 → no condition
      const microRaw  = lastRaw[trackBase + MICRO_TIMING_OFFSET + s];
      const retLenRaw = lastRaw[trackBase + RETRIG_LENGTH_OFFSET + s];
      const retRatRaw = lastRaw[trackBase + RETRIG_RATE_OFFSET + s];
      let r = 0;
      r  = (noteRaw   & 0x80) >> 1;  // bit 6  (always 0 for valid conditions 0-56)
      r |= (microRaw  & 0xC0) >> 2;  // bits 5..4
      r |= (retLenRaw & 0x80) >> 4;  // bit 3
      r |= (retRatRaw & 0xE0) >> 5;  // bits 2..0
      return r;
    }

    function buildTrigSection(t, s, flags) {
      const trackBase = 4 + t * TRACK_V5_SZ;

      const noteRaw  = lastRaw[trackBase + NOTE_OFFSET + s];
      const defNote  = lastRaw[trackBase + DEFAULT_NOTE_OFFSET];
      const noteLocked = (noteRaw !== 0xFF && noteRaw !== 0x7F);
      const noteVal  = noteLocked ? midiNoteToName(noteRaw & 0x7F) : midiNoteToName(defNote);

      const veloRaw  = lastRaw[trackBase + VELOCITY_OFFSET + s];
      const defVelo  = lastRaw[trackBase + DEFAULT_VELOCITY_OFFSET];
      const veloLocked = veloRaw !== 0xFF;
      const veloVal  = veloLocked ? veloRaw : defVelo;

      const lenRaw   = lastRaw[trackBase + NOTE_LEN_OFFSET + s];
      const defLen   = lastRaw[trackBase + DEFAULT_NOTE_LEN_OFFSET];
      const lenLocked = lenRaw !== 0xFF;
      const lenVal   = noteLenStr(lenLocked ? lenRaw : defLen);

      const prob     = lastRaw[trackBase + TRIG_PROBABILITY_OFFSET];

      // Per-step trig condition overrides the track-level probability
      const trigCond   = getTrigCondition(trackBase, s);
      const probStr    = trigCond !== null
        ? (TRIG_COND_NAMES[trigCond] ?? String(trigCond))
        : (prob + '%');
      const probLocked = trigCond !== null;

      const sndLock  = lastRaw[trackBase + SOUND_LOCK_OFFSET + s];
      const hasSnd   = sndLock !== 0xFF;

      const body = document.createElement('div');
      body.className = 'sp-params';
      body.appendChild(makeParamRow('SND',  hasSnd ? (sndLock + 1) : 'TRK', hasSnd));
      body.appendChild(makeParamRow('NOTE', noteVal,                   noteLocked));
      body.appendChild(makeParamRow('VELO', veloVal,                   veloLocked));
      body.appendChild(makeParamRow('LEN',  lenVal,                    lenLocked));
      body.appendChild(makeParamRow('PROB', probStr,                   probLocked));

      // Micro-timing (-23..+23): sign-extend 6-bit value from lower bits
      const microRaw    = lastRaw[trackBase + MICRO_TIMING_OFFSET + s];
      const microVal    = microRaw & 0x3F;
      const microSigned = (microVal & 0x20) ? microVal - 64 : microVal;
      const utimeStr    = (microSigned > 0 ? '+' : '') + microSigned;
      body.appendChild(makeParamRow('UTIME', utimeStr, microSigned !== 0));

      // SYN / SMP / ENV / LFO retrigger switches
      const swDefs = [
        { lbl: 'SYN', bit: AR_TRIG_SYN_PL_SW },
        { lbl: 'SMP', bit: AR_TRIG_SMP_PL_SW },
        { lbl: 'ENV', bit: AR_TRIG_ENV_PL_SW },
        { lbl: 'LFO', bit: AR_TRIG_LFO_PL_SW },
      ];
      const swRow = document.createElement('div');
      swRow.className = 'sp-sw-row';
      for (const sw of swDefs) {
        const on = (flags & sw.bit) !== 0;
        const el = document.createElement('div');
        // OFF is the deviation from default (default_trig_flags sets all SW bits ON)
        el.className = 'sp-flag' + (on ? ' on' : '');
        el.textContent = sw.lbl;
        swRow.appendChild(el);
      }
      body.appendChild(swRow);

      return makeSec('TRIG', body);
    }

    // RETRIG section: RATE, LEN, VEL — always shown; highlighted when retrig is active
    function buildRetrigSection(t, s, flags) {
      const trackBase = 4 + t * TRACK_V5_SZ;
      const isRetrig  = (flags & AR_TRIG_RETRIG) !== 0;

      const rateRaw   = lastRaw[trackBase + RETRIG_RATE_OFFSET   + s] & 0x1F;
      const lenRaw    = lastRaw[trackBase + RETRIG_LENGTH_OFFSET  + s] & 0x7F;
      const velRaw    = lastRaw[trackBase + RETRIG_VELO_OFFSET    + s];
      const velSigned = velRaw > 127 ? velRaw - 256 : velRaw;

      const rateStr   = RETRIG_RATE_LABELS[rateRaw] ?? String(rateRaw);
      const lenStr    = lenRaw === 127 ? '\u221E' : String(lenRaw);
      const velStr    = (velSigned >= 0 ? '+' : '') + velSigned;

      const body = document.createElement('div');
      body.className = 'sp-params';
      body.appendChild(makeParamRow('RATE', rateStr, isRetrig));
      body.appendChild(makeParamRow('LEN',  lenStr,  isRetrig));
      body.appendChild(makeParamRow('VEL',  velStr,  isRetrig && velSigned !== 0));
      return makeSec('RETRIG', body);
    }

    // SRC / SMPL / FLTR / AMP / LFO sections
    function buildParamSection(secKey, t, s) {
      const body = document.createElement('div');
      body.className = 'sp-params';

      for (const [ptStr, info] of Object.entries(PLOCK_INFO)) {
        if (info.sec !== secKey) continue;
        const pt = Number(ptStr);

        const kitDef = getKitDefault(t, info.sndOff);
        const plArr  = plockValues && plockValues[t].get(pt);
        const plVal  = plArr ? plArr[s] : 0xFF;
        const locked = plVal !== 0xFF;

        const displayVal = locked ? plVal : (kitDef !== null ? kitDef : '?');
        body.appendChild(makeParamRow(info.lbl, displayVal, locked));
      }

      return makeSec(secKey, body);
    }

    // ─── Panel helpers ────────────────────────────────────────────────────────

    function makeSec(title, bodyEl) {
      const sec = document.createElement('div');
      sec.className = 'sp-sec';
      const head = document.createElement('div');
      head.className = 'sp-sec-head';
      head.textContent = title;
      sec.appendChild(head);
      sec.appendChild(bodyEl);
      return sec;
    }

    function makeParamRow(lbl, val, locked) {
      const row = document.createElement('div');
      row.className = 'sp-param';
      const l = document.createElement('span');
      l.className = 'sp-lbl';
      l.textContent = lbl;
      const v = document.createElement('span');
      v.className = 'sp-val' + (locked ? ' locked' : '');
      v.textContent = val;
      row.appendChild(l);
      row.appendChild(v);
      return row;
    }

    // ─── Kit default lookup ───────────────────────────────────────────────────
    // Returns the default value byte for a plock-able parameter from the decoded
    // kit. soundOff is the offset within ar_sound_t; for s_u16_t fields the hi
    // byte (first in memory, lower address) carries the 0-127 value.

    function getKitDefault(trackIdx, soundOff) {
      if (!lastKit || trackIdx >= 12) return null;  // FX track has no ar_sound_t
      const base = KIT_TRACKS_BASE + trackIdx * AR_SOUND_V5_SZ;
      if (base + soundOff >= lastKit.length) return null;
      return lastKit[base + soundOff];
    }

    // ─── Display helpers ──────────────────────────────────────────────────────

    // MIDI note → name using AR convention: note 60 = C3 (C0 = note 24)
    function midiNoteToName(n) {
      if (n > 127) return '?';
      const NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      return NAMES[n % 12] + (Math.floor(n / 12) - 2);
    }

    // Note length encoding: 0xFF = unset (use default), values 0-127
    function noteLenStr(v) {
      if (v === 0xFF) return 'DEF';
      if (v === 0x7F) return '\u221E';  // ∞
      return String(v);
    }

  </script>
</body>
</html>
