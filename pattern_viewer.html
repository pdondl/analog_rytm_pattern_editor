<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analog Rytm Pattern Viewer</title>
  <style>
    :root {
      --bg:         #111;
      --surface:    #1c1c1c;
      --border:     #2a2a2a;
      --fg:         #ddd;
      --muted:      #555;
      --accent:     #e05a00;
      --trig-on:    #e05a00;
      --trig-off:   #202020;
      --step-size:  32px;
      --step-gap:   2px;
      --group-gap:  8px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--fg);
      font-family: 'Courier New', monospace;
      font-size: 13px;
      padding: 28px;
      min-height: 100vh;
    }

    h1 {
      color: var(--accent);
      font-size: 1.1em;
      letter-spacing: 4px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.8em;
      letter-spacing: 1px;
      margin-bottom: 24px;
    }

    /* Controls */
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    button {
      background: var(--surface);
      border: 1px solid #3a3a3a;
      color: var(--fg);
      padding: 7px 16px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85em;
      letter-spacing: 1px;
      border-radius: 2px;
    }
    button:hover:not(:disabled) {
      border-color: var(--accent);
      color: var(--accent);
    }
    button:disabled { opacity: 0.35; cursor: default; }

    #status {
      font-size: 0.8em;
      padding: 6px 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 2px;
      color: var(--muted);
    }
    #status.ok  { color: #5cb85c; border-color: #2d4a2d; }
    #status.err { color: #d9534f; border-color: #4a2d2d; }

    #port-info {
      font-size: 0.75em;
      color: var(--muted);
      margin-bottom: 20px;
      min-height: 1em;
    }

    /* Pattern meta info */
    #pattern-meta {
      font-size: 0.8em;
      color: var(--muted);
      margin-bottom: 14px;
      letter-spacing: 1px;
      min-height: 1em;
    }
    #pattern-meta span { color: var(--fg); }

    /* Grid */
    #grid-wrap { overflow-x: auto; padding-bottom: 8px; }

    .grid {
      display: inline-block;
      white-space: nowrap;
    }

    /* Step-number ruler */
    .ruler-row {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .track-label-space {
      flex: 0 0 66px;
    }
    .ruler-groups {
      display: flex;
      gap: var(--group-gap);
    }
    .ruler-group {
      display: flex;
      gap: var(--step-gap);
    }
    .ruler-num {
      width: var(--step-size);
      text-align: center;
      font-size: 11px;
      color: var(--muted);
      line-height: 1;
    }

    /* Track rows */
    .track-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .track-label {
      flex: 0 0 66px;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      padding-right: 10px;
      gap: 2px;
      font-size: 0.75em;
      color: var(--muted);
      letter-spacing: 1px;
    }
    .track-meta {
      font-size: 0.82em;
      color: #444;
      letter-spacing: 0;
    }
    .track-steps {
      display: flex;
      gap: var(--group-gap);
    }
    .step-group {
      display: flex;
      gap: var(--step-gap);
    }

    .step {
      width: var(--step-size);
      height: var(--step-size);
      border-radius: 1px;
      background: var(--trig-off);
      border: 1px solid #2a2a2a;
      cursor: default;
      flex-shrink: 0;
      position: relative;
    }
    .step.on {
      background: var(--trig-on);
      border-color: #ff7722;
      box-shadow: 0 0 5px rgba(224, 90, 0, 0.4);
    }
    /* Accented trig: bright amber */
    .step.on.accent {
      background: #ffbb44;
      border-color: #ffdd77;
      box-shadow: 0 0 6px rgba(255, 187, 68, 0.5);
    }
    /* Muted trig: grey — programmed but won't fire */
    .step.on.mute {
      background: #404040;
      border-color: #606060;
      box-shadow: none;
    }
    /* Steps beyond track length are dimmed */
    .step.inactive {
      opacity: 0.2;
    }
    /* Trig modifier dots */
    .trig-dot {
      position: absolute;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      pointer-events: none;
    }
    .trig-dot.retrig { top:    2px; right: 2px; background: #ddcc22; }
    .trig-dot.swing  { bottom: 2px; left:  2px; background: #4499ff; }
    .trig-dot.slide  { bottom: 2px; right: 2px; background: #44cc77; }

    /* Lock trig: parameter lock present, but no sound trigger */
    .step.lock-trig {
      background: #0e1f2a;
      border-color: #2a6080;
      box-shadow: 0 0 3px rgba(42, 96, 128, 0.35);
    }
    /* Plock triangle indicator — top-left corner of triggered step boxes */
    .step.has-plock::before {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 0; height: 0;
      border-style: solid;
      border-width: 7px 7px 0 0;
      border-color: #cc44aa transparent transparent transparent;
    }
    /* Outer wrapper for steps — provides positioning context for slide lines */
    .steps-outer {
      position: relative;
    }
    /* Slide connector line drawn below the step boxes */
    .slide-line {
      position: absolute;
      top: 34px;
      height: 2px;
      background: #44cc77;
      border-radius: 1px;
      pointer-events: none;
    }

    /* Page toggle */
    .page-ctrl {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }
    .page-btn.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Group separator lines */
    .group-sep {
      width: 1px;
      height: var(--step-size);
      background: #2a2a2a;
      flex-shrink: 0;
      align-self: center;
    }

    .note {
      margin-top: 22px;
      font-size: 0.72em;
      color: var(--muted);
      line-height: 1.6;
    }
    .note a { color: #666; }
  </style>
</head>
<body>

  <h1>Analog Rytm Pattern Viewer</h1>
  <div class="subtitle">USB MIDI &mdash; Workbuffer &mdash; Step trigs</div>

  <div class="controls">
    <button id="btn-connect">Connect MIDI</button>
    <button id="btn-refresh" disabled>Request Pattern</button>
    <div id="status">Not connected</div>
  </div>

  <div id="port-info"></div>
  <div id="pattern-meta"></div>

  <div class="page-ctrl">
    <button id="btn-page0" class="page-btn active">1 &ndash; 32</button>
    <button id="btn-page1" class="page-btn">33 &ndash; 64</button>
  </div>

  <div id="grid-wrap">
    <div class="grid" id="grid"></div>
  </div>

  <div class="note">
    Connects to the first MIDI port whose name contains &ldquo;rytm&rdquo; (case-insensitive).<br>
    Requests the current workbuffer pattern via SysEx. Dimmed cells = beyond track step count.<br>
    Trig colours:
      <span style="color:#e05a00">&#9632;</span>&thinsp;normal &ensp;
      <span style="color:#ffbb44">&#9632;</span>&thinsp;accent &ensp;
      <span style="color:#606060">&#9632;</span>&thinsp;mute &ensp;
      <span style="color:#2a6080">&#9632;</span>&thinsp;lock trig (plock, no sound) &mdash;
    <span style="color:#cc44aa">&#9699;</span>&thinsp;plock on trig (triangle = parameter lock active) &mdash;
    Dots:
      <span style="color:#ddcc22">&#9679;</span>&thinsp;retrig &ensp;
      <span style="color:#4499ff">&#9679;</span>&thinsp;swing (hidden when pattern swing = 50%) &ensp;
      <span style="color:#44cc77">&#9679;</span>&thinsp;slide.<br>
    Slide: <span style="color:#44cc77">&#9644;</span>&thinsp;green line below row, from slide step to next trig&thinsp;/&thinsp;lock (same page only).<br>
    FW 1.70 binary format (compatible with 1.72).
  </div>

  <script>
    // ─── Constants from libanalogrytm/sysex.h and pattern.h ──────────────────

    const AR_PRODUCT_ID              = 0x07;
    const AR_ELEKTRON_MFR_1          = 0x20;
    const AR_ELEKTRON_MFR_2          = 0x3C;
    const AR_SYSEX_DUMP_ID_PATTERN   = 0x54;   // saved pattern dump
    const AR_SYSEX_DUMPX_ID_PATTERN  = 0x5A;   // workbuffer pattern dump
    const AR_TRIG_ENABLE             = 0x0001;  // bit 0 of 14-bit trig flags
    const AR_TRIG_RETRIG             = 0x0002;  // bit 1
    const AR_TRIG_MUTE               = 0x0004;  // bit 2
    const AR_TRIG_ACCENT             = 0x0008;  // bit 3
    const AR_TRIG_SWING              = 0x0010;  // bit 4
    const AR_TRIG_SLIDE              = 0x0020;  // bit  5: slide
    // Bits 6-13 — plock enable / state flags (from pattern.h AR_TRIG_xxx):
    const AR_TRIG_LFO_PL_EN          = 0x0040;  // bit  6: enable LFO p-lock
    const AR_TRIG_SYN_PL_SW          = 0x0080;  // bit  7: p-locked SYN state  (default-set on ALL triggered steps)
    const AR_TRIG_SMP_PL_SW          = 0x0100;  // bit  8: p-locked SMP state  (default-set on ALL triggered steps)
    const AR_TRIG_ENV_PL_SW          = 0x0200;  // bit  9: p-locked ENV state  (default-set on ALL triggered steps)
    const AR_TRIG_LFO_PL_SW          = 0x0400;  // bit 10: p-locked LFO state  (default-set on ALL triggered steps)
    const AR_TRIG_SYN_PL_EN          = 0x0800;  // bit 11: enable SYN p-lock
    const AR_TRIG_SMP_PL_EN          = 0x1000;  // bit 12: enable SMP p-lock
    const AR_TRIG_ENV_PL_EN          = 0x2000;  // bit 13: enable ENV p-lock
    // NOTE: the _SW bits are set by default_trig_flags on every triggered step, so they
    // cannot be used to detect user-placed plocks. Use the plock_seqs scan instead.

    const AR_NUM_TRACKS              = 13;
    const AR_NUM_STEPS               = 64;
    const TRACK_V5_SZ                = 0x0281;  // 641 bytes / track (FW1.70)
    const TRIG_BITS_OFFSET           = 0;       // trig_bits[112] at track struct offset 0
    const NUM_STEPS_OFFSET           = 0x0235;  // num_steps  — struct offset (pattern @0x0239 for track 0)
    const TRACK_SPEED_OFFSET         = 0x0277;  // flags_and_speed — struct offset (pattern @0x027B for track 0)
    // P-Lock sequences: ar_plock_seq_t plock_seqs[72] at pattern raw offset 0x2091.
    // Each seq: [plock_type u8][track_nr u8][data u8 × 64] = 66 bytes.
    // Active seq: plock_type != 0xFF && track_nr != 0xFF.
    // data[stepIdx] == 0xFF means no lock for that step (same 0xFF=unused convention as notes/velocities).
    const PLOCK_SEQS_BASE            = 0x2091;  // pattern offset of plock_seqs[0]
    const PLOCK_SEQ_SZ               = 0x42;    // 66 bytes per plock_seq
    const NUM_PLOCK_SEQS             = 72;
    const MASTER_LENGTH_OFFSET       = 0x3321;  // master_length (s_u16_t, little-endian)
    const KIT_NUMBER_OFFSET          = 0x3325;  // kit_number (0–127, 0xFF=unsaved)
    const SWING_AMOUNT_OFFSET        = 0x3326;  // swing_amount (0=50%, 1–30=51–80%)
    const BPM_MSB_OFFSET             = 0x332A;  // BPM high byte (value/120 = BPM)
    const BPM_LSB_OFFSET             = 0x332B;  // BPM low byte

    // Track speed: bits 2–0 of flags_and_speed
    const TRACK_SPEED_LABELS = ['2x', '3/2x', '1x', '3/4x', '1/2x', '1/4x', '1/8x'];

    // Workbuffer pattern request:
    //   F0 00 20 3C 07 <devId=0> <reqId=0x6A> <verHi=01> <verLo=01>
    //   <objNr=0> 00 00 00 05 F7
    // 0x6A = AR_SYSEX_REQUESTX_ID_BASE (0x68) + AR_TYPE_PATTERN (0x02)
    const PATTERN_REQUEST_X = new Uint8Array([
      0xF0, 0x00, 0x20, 0x3C, 0x07,
      0x00,       // devId = 0
      0x6A,       // AR_SYSEX_REQUESTX_ID_PATTERN (workbuffer)
      0x01, 0x01, // container version 1.1
      0x00,       // object number (& 0x7F = 0)
      0x00, 0x00, 0x00, 0x05,
      0xF7
    ]);

    const TRACK_NAMES = ['BD','SD','RS','CP','BT','LT','MT','HT','CH','OH','CY','CB','FX'];

    // ─── State ────────────────────────────────────────────────────────────────

    let midiAccess  = null;
    let rytmInput   = null;
    let rytmOutput  = null;
    let sysexBuf    = [];
    let inSysex     = false;
    let lastRaw     = null;
    let stepPage    = 0;

    // ─── UI refs ──────────────────────────────────────────────────────────────

    const btnConnect  = document.getElementById('btn-connect');
    const btnRefresh  = document.getElementById('btn-refresh');
    const btnPage0    = document.getElementById('btn-page0');
    const btnPage1    = document.getElementById('btn-page1');
    const statusEl    = document.getElementById('status');
    const portInfoEl  = document.getElementById('port-info');
    const metaEl      = document.getElementById('pattern-meta');
    const gridEl      = document.getElementById('grid');

    // ─── UI helpers ───────────────────────────────────────────────────────────

    function setStatus(msg, cls) {
      statusEl.textContent = msg;
      statusEl.className   = cls || '';
    }

    // ─── MIDI connect ─────────────────────────────────────────────────────────

    async function connectMidi() {
      setStatus('Connecting to MIDI…');
      try {
        midiAccess = await navigator.requestMIDIAccess({ sysex: true });
      } catch (e) {
        setStatus('MIDI access denied: ' + e.message, 'err');
        return;
      }
      midiAccess.onstatechange = () => {
        const hadRytm = !!(rytmInput && rytmOutput);
        findPorts();
        // Auto-request when Analog Rytm appears (e.g. USB plug-in after load)
        if (!hadRytm && rytmInput && rytmOutput) requestPattern();
      };
      findPorts();
      if (rytmInput && rytmOutput) requestPattern();
    }

    btnConnect.addEventListener('click', connectMidi);
    btnRefresh.addEventListener('click', requestPattern);

    function findPorts() {
      rytmInput  = null;
      rytmOutput = null;

      const inNames  = [];
      const outNames = [];

      for (const [, p] of midiAccess.inputs) {
        inNames.push(p.name);
        if (p.name.toLowerCase().includes('rytm')) {
          rytmInput = p;
        }
      }
      for (const [, p] of midiAccess.outputs) {
        outNames.push(p.name);
        if (p.name.toLowerCase().includes('rytm')) {
          rytmOutput = p;
        }
      }

      portInfoEl.textContent =
        'IN: ' + (inNames.join(', ') || '—') +
        '   OUT: ' + (outNames.join(', ') || '—');

      if (rytmInput && rytmOutput) {
        rytmInput.onmidimessage = onMidiMessage;
        setStatus('Connected → ' + rytmInput.name, 'ok');
        btnRefresh.disabled = false;
      } else {
        setStatus('Analog Rytm not found — connect the device and try again.', 'err');
        btnRefresh.disabled = true;
      }
    }

    btnPage0.addEventListener('click', () => {
      stepPage = 0;
      btnPage0.classList.add('active');
      btnPage1.classList.remove('active');
      if (lastRaw) renderGrid(lastRaw, stepPage);
    });

    btnPage1.addEventListener('click', () => {
      stepPage = 1;
      btnPage1.classList.add('active');
      btnPage0.classList.remove('active');
      if (lastRaw) renderGrid(lastRaw, stepPage);
    });

    // Auto-connect on page load
    connectMidi();

    function requestPattern() {
      if (!rytmOutput) return;
      sysexBuf = [];
      inSysex  = false;
      setStatus('Requesting pattern…');
      rytmOutput.send(PATTERN_REQUEST_X);
    }

    // ─── Receive & reassemble SysEx ───────────────────────────────────────────
    // Web MIDI may deliver large SysEx messages in chunks, so we buffer until F7.

    function onMidiMessage(ev) {
      const data = ev.data;
      for (let i = 0; i < data.length; i++) {
        const b = data[i];
        if (b === 0xF0) {
          inSysex  = true;
          sysexBuf = [0xF0];
        } else if (inSysex) {
          sysexBuf.push(b);
          if (b === 0xF7) {
            inSysex = false;
            handleSysex(new Uint8Array(sysexBuf));
            sysexBuf = [];
          }
        }
      }
    }

    // ─── SysEx handler ────────────────────────────────────────────────────────

    function handleSysex(syx) {
      // Validate Elektron Analog Rytm pattern dump header (10 bytes):
      //   [F0][00][20][3C][07][devId][dumpId][verHi][verLo][objNr]
      if (syx.length < 20) return;
      if (syx[0] !== 0xF0)           return;
      if (syx[1] !== 0x00)           return;
      if (syx[2] !== AR_ELEKTRON_MFR_1) return;
      if (syx[3] !== AR_ELEKTRON_MFR_2) return;
      if (syx[4] !== AR_PRODUCT_ID)     return;

      const dumpId = syx[6];
      const isPattern =
        dumpId === AR_SYSEX_DUMP_ID_PATTERN ||   // 0x54: saved-slot dump
        dumpId === AR_SYSEX_DUMPX_ID_PATTERN;    // 0x5A: workbuffer dump

      if (!isPattern) return;

      const objNr   = syx[9];
      const isWB    = (dumpId === AR_SYSEX_DUMPX_ID_PATTERN);
      const patName = isWB ? 'Workbuffer' : patternSlotName(objNr);

      setStatus('Decoding ' + syx.length + ' bytes…');

      let raw;
      try {
        raw = decodeSysex7to8(syx);
      } catch (e) {
        setStatus('Decode error: ' + e.message, 'err');
        console.error(e);
        return;
      }

      const kitNum     = raw.length > KIT_NUMBER_OFFSET     ? raw[KIT_NUMBER_OFFSET]    : 0xFF;
      const kitStr     = (kitNum === 0xFF) ? '—' : String(kitNum + 1).padStart(2, '0');
      const bpmRaw     = raw.length > BPM_LSB_OFFSET
        ? (raw[BPM_MSB_OFFSET] << 8) | raw[BPM_LSB_OFFSET] : 0;
      const bpmStr     = bpmRaw ? (bpmRaw / 120).toFixed(1) : '—';
      const swingAmt   = raw.length > SWING_AMOUNT_OFFSET  ? raw[SWING_AMOUNT_OFFSET]  : 0;
      const masterLen  = raw.length > MASTER_LENGTH_OFFSET + 1
        ? raw[MASTER_LENGTH_OFFSET] | (raw[MASTER_LENGTH_OFFSET + 1] << 8) : 0;
      const masterStr  = (masterLen === 0 || masterLen > 128) ? 'INF' : masterLen;

      metaEl.innerHTML =
        'Pattern: <span>' + patName + '</span> &ensp;' +
        'Kit: <span>'     + kitStr  + '</span> &ensp;' +
        'BPM: <span>'     + bpmStr  + '</span> &ensp;' +
        'Swing: <span>'   + (50 + swingAmt) + '%</span> &ensp;' +
        'Master: <span>'  + masterStr + '</span>';

      lastRaw = raw;
      renderGrid(raw, stepPage);
      setStatus('Ready', 'ok');
    }

    // Convert bank+number (0-based) → e.g. "A01"
    function patternSlotName(n) {
      const bank = String.fromCharCode(65 + Math.floor(n / 16));
      const slot = String(1 + (n % 16)).padStart(2, '0');
      return bank + slot;
    }

    // ─── 7-bit SysEx → 8-bit raw decode ──────────────────────────────────────
    //
    // Mirrors ar_sysex_decode() in sysex.c.
    //
    // SysEx message layout (all byte indices within syx[]):
    //   [0..9]   : 10-byte header (F0 + 9 data bytes)
    //   [10..-6] : encoded payload, syxDatSz bytes
    //   [-5..-4] : checksum (2 bytes, 7-bit each)
    //   [-3..-2] : data size (2 bytes, 7-bit each)
    //   [-1]     : F7
    //
    // Every 8 payload bytes → 7 raw bytes:
    //   byte 0 (msbs): bit6=MSB of out[0], bit5=MSB of out[1], … bit0=MSB of out[6]
    //   bytes 1..7   : lower 7 bits of out[0..6]

    function decodeSysex7to8(syx) {
      const dataStart = 10;
      const dataEnd   = syx.length - 5;  // chkHi chkLo szHi szLo F7
      const syxDatSz  = dataEnd - dataStart;

      if (syxDatSz <= 0) throw new Error('Empty payload');

      const raw  = [];
      let pkbNr  = 0;
      let msbs   = 0;

      for (let i = 0; i < syxDatSz; i++) {
        const b = syx[dataStart + i];
        if (pkbNr === 0) {
          msbs = b;             // MSB accumulator byte
        } else {
          raw.push(b | (msbs & 0x80));  // restore high bit
        }
        msbs  = (msbs << 1) & 0xFF;    // shift MSB of next byte into position 7
        pkbNr = (pkbNr + 1) & 7;
      }

      return new Uint8Array(raw);
    }

    // ─── Trig flags from packed 14-bit bitstream ──────────────────────────────
    //
    // Mirrors ar_pattern_track_get_trig_flags() in pattern.c.
    //
    // Each step's 14 trig bits are stored consecutively in a packed bit array.
    // Bit 0 of the result = AR_TRIG_ENABLE.

    function getTrigFlags(trigBits, stepIdx) {
      const startBit = 14 * stepIdx;
      const numBits  = 14;
      let r        = 0;
      let byteOff  = startBit >> 3;
      let bitOff   = startBit - (byteOff << 3);
      let outShift = numBits;
      let bitsLeft = numBits;

      while (bitsLeft > 0) {
        const bitsAvail = 8 - bitOff;
        if (bitsLeft < bitsAvail) {
          outShift -= bitsLeft;
          r |= ((trigBits[byteOff] >> (bitsAvail - bitsLeft)) & ((1 << bitsLeft) - 1)) << outShift;
          bitsLeft = 0;
        } else {
          outShift -= bitsAvail;
          r |= (trigBits[byteOff] & ((1 << bitsAvail) - 1)) << outShift;
          bitsLeft -= bitsAvail;
          bitOff    = 0;
          byteOff++;
        }
      }
      return r;
    }

    // ─── Render grid ──────────────────────────────────────────────────────────
    //
    // ar_pattern_t layout (V5 / FW1.70, raw 8-bit bytes):
    //   magic[4]      @0
    //   tracks[13]    @4, each TRACK_V5_SZ (641) bytes
    //     trig_bits[112] at track offset 0     (14 bits per step, 64 steps)
    //     num_steps      at track offset 0x235 (1..64)

    function renderGrid(raw, page) {
      gridEl.innerHTML = '';

      const GROUPS    = 2;
      const GROUP_SZ  = 16;
      const STEP_W    = 32;   // matches --step-size
      const STEP_GAP  = 2;    // matches --step-gap
      const GROUP_GAP = 8;    // matches --group-gap
      const stepOffset = page * 32;

      // Swing amount: 0 = 50% (no swing), 1–30 = 51–80%.
      const swingAmount = (raw.length > SWING_AMOUNT_OFFSET) ? raw[SWING_AMOUNT_OFFSET] : 0;

      // ── Scan plock_seqs to build a per-track, per-step plock presence map ──
      // This is the authoritative source: the _SW trig-flag bits are set by
      // default_trig_flags on every triggered step, so they cannot be used for
      // plock detection. We scan the actual plock_seqs instead.
      //
      // plockMap[track][step] = 1  when any active plock_seq for that track has
      // data[step] != 0xFF (0xFF = "no lock for this step", same convention as
      // notes / velocities / note_lengths).
      const plockMap = Array.from({length: AR_NUM_TRACKS}, () => new Uint8Array(AR_NUM_STEPS));
      const plockSeqsEnd = PLOCK_SEQS_BASE + NUM_PLOCK_SEQS * PLOCK_SEQ_SZ;
      if (raw.length >= plockSeqsEnd) {
        for (let si = 0; si < NUM_PLOCK_SEQS; si++) {
          const base   = PLOCK_SEQS_BASE + si * PLOCK_SEQ_SZ;
          const plType = raw[base];
          const trkNr  = raw[base + 1];
          if (plType === 0xFF || trkNr === 0xFF || trkNr >= AR_NUM_TRACKS) continue;
          for (let s = 0; s < AR_NUM_STEPS; s++) {
            if (raw[base + 2 + s] !== 0xFF) plockMap[trkNr][s] = 1;
          }
        }
      }

      // ── X-centre of step pageIdx (0-31) inside the track-steps container ──
      // groupWidth = 16*32 + 15*2 = 542 px
      function stepCenterX(pageIdx) {
        const g = Math.floor(pageIdx / GROUP_SZ);
        const s = pageIdx % GROUP_SZ;
        const groupWidth = GROUP_SZ * STEP_W + (GROUP_SZ - 1) * STEP_GAP;
        return g * (groupWidth + GROUP_GAP) + s * (STEP_W + STEP_GAP) + STEP_W / 2;
      }

      // ── Ruler (step numbers) ──────────────────────────────────────────────
      const ruler = document.createElement('div');
      ruler.className = 'ruler-row';

      const rulerSpace = document.createElement('div');
      rulerSpace.className = 'track-label-space';
      ruler.appendChild(rulerSpace);

      const rulerGroups = document.createElement('div');
      rulerGroups.className = 'ruler-groups';
      for (let g = 0; g < GROUPS; g++) {
        const grp = document.createElement('div');
        grp.className = 'ruler-group';
        for (let s = 0; s < GROUP_SZ; s++) {
          const n = document.createElement('div');
          n.className = 'ruler-num';
          const stepNum = stepOffset + g * GROUP_SZ + s + 1;
          if (stepNum % 4 === 1) n.textContent = stepNum;
          grp.appendChild(n);
        }
        rulerGroups.appendChild(grp);
      }
      ruler.appendChild(rulerGroups);
      gridEl.appendChild(ruler);

      // ── Track rows ────────────────────────────────────────────────────────
      for (let t = 0; t < AR_NUM_TRACKS; t++) {
        const trackBase  = 4 + t * TRACK_V5_SZ;
        const trigBits   = raw.subarray(trackBase + TRIG_BITS_OFFSET, trackBase + 112);
        const numSteps   = raw[trackBase + NUM_STEPS_OFFSET];
        const speedByte  = raw[trackBase + TRACK_SPEED_OFFSET];
        const speedStr   = TRACK_SPEED_LABELS[speedByte & 0x07] || '1x';

        const row = document.createElement('div');
        row.className = 'track-row';

        // ── Label ──
        const label = document.createElement('div');
        label.className = 'track-label';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = TRACK_NAMES[t];
        const metaSpan = document.createElement('span');
        metaSpan.className = 'track-meta';
        metaSpan.textContent = speedStr + '\u00B7' + numSteps;
        label.appendChild(nameSpan);
        label.appendChild(metaSpan);
        row.appendChild(label);

        // ── Steps outer (provides positioning context for slide lines) ──
        const stepsOuter = document.createElement('div');
        stepsOuter.className = 'steps-outer';

        const stepsWrap = document.createElement('div');
        stepsWrap.className = 'track-steps';

        // Per-page arrays to collect info for slide line rendering
        const slideSteps  = new Array(32).fill(false); // step has SLIDE trig
        const activeSteps = new Array(32).fill(false); // step is a trig or lock-trig

        for (let g = 0; g < GROUPS; g++) {
          const grp = document.createElement('div');
          grp.className = 'step-group';

          for (let s = 0; s < GROUP_SZ; s++) {
            const pageIdx  = g * GROUP_SZ + s;
            const stepIdx  = stepOffset + pageIdx;
            const flags    = getTrigFlags(trigBits, stepIdx);
            const isOn     = (flags & AR_TRIG_ENABLE) !== 0;
            const isAccent = (flags & AR_TRIG_ACCENT) !== 0;
            const isMute   = (flags & AR_TRIG_MUTE)   !== 0;
            const isRetrig = (flags & AR_TRIG_RETRIG) !== 0;
            const hasSwing = (flags & AR_TRIG_SWING)  !== 0;
            const isSlide  = (flags & AR_TRIG_SLIDE)  !== 0;
            const beyond   = stepIdx >= numSteps;
            // Plock detection via plock_seqs (not trig flags — see note above).
            const hasPlock = !beyond && plockMap[t][stepIdx] !== 0;

            // Collect info for slide lines (only within active track length)
            if (!beyond) {
              if (isOn || hasPlock)  activeSteps[pageIdx] = true;
              if (isOn && isSlide)   slideSteps[pageIdx]  = true;
            }

            const cell = document.createElement('div');
            let cls = 'step';

            if (isOn) {
              cls += ' on';
              if (isAccent && !isMute) cls += ' accent';
              if (isMute)              cls += ' mute';
              if (hasPlock)            cls += ' has-plock';
            } else if (hasPlock) {
              // Lock trig: parameter lock on a non-triggered step (yellow on hardware)
              cls += ' lock-trig';
            }

            if (beyond) cls += ' inactive';
            cell.className = cls;

            // Modifier dots (only on triggered steps)
            if (isOn) {
              if (isRetrig) { const d = document.createElement('div'); d.className = 'trig-dot retrig'; cell.appendChild(d); }
              if (hasSwing && swingAmount !== 0) { const d = document.createElement('div'); d.className = 'trig-dot swing'; cell.appendChild(d); }
              if (isSlide)  { const d = document.createElement('div'); d.className = 'trig-dot slide';  cell.appendChild(d); }
            }

            // Tooltip
            const modParts = [];
            if (hasPlock) modParts.push('PLOCK');
            if (isAccent) modParts.push('ACCENT');
            if (isMute)   modParts.push('MUTE');
            if (isRetrig) modParts.push('RETRIG');
            if (hasSwing && swingAmount !== 0) modParts.push('SWING');
            if (isSlide)  modParts.push('SLIDE');
            cell.title = TRACK_NAMES[t] + ' · step ' + (stepIdx + 1)
              + (isOn              ? ' · TRIG' : '')
              + (!isOn && hasPlock ? ' · LOCK' : '')
              + (modParts.length   ? ' [' + modParts.join(', ') + ']' : '')
              + (beyond            ? ' · beyond' : '');

            grp.appendChild(cell);
          }
          stepsWrap.appendChild(grp);
        }

        stepsOuter.appendChild(stepsWrap);

        // ── Slide lines ───────────────────────────────────────────────────
        // For each step that has a SLIDE trig, draw a horizontal line from
        // its centre to the centre of the next trig or lock-trig on the page.
        for (let i = 0; i < 32; i++) {
          if (!slideSteps[i]) continue;
          for (let j = i + 1; j < 32; j++) {
            if (activeSteps[j]) {
              const x1 = stepCenterX(i);
              const x2 = stepCenterX(j);
              const line = document.createElement('div');
              line.className = 'slide-line';
              line.style.left  = x1 + 'px';
              line.style.width = (x2 - x1) + 'px';
              stepsOuter.appendChild(line);
              break;
            }
          }
        }

        row.appendChild(stepsOuter);
        gridEl.appendChild(row);
      }
    }
  </script>
</body>
</html>
